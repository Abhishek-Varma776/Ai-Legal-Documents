Optimized Full-Stack Prompt with Legal Document Check
You are an expert full-stack developer. Build a complete working full-stack website called **LexiExplain**, an AI-powered legal document simplifier.

# PROBLEM CONTEXT
Legal documents such as rental agreements, loan contracts, and terms of service are filled with jargon and hidden clauses. Ordinary users cannot understand them, leading to financial or legal risks. Lawyers are costly, so people need an affordable, private AI-powered first tool to simplify legal documents and highlight risks.

# OBJECTIVE
Develop a secure, private, and intelligent full-stack web application that allows users to:
1. Upload legal documents (PDF, DOCX, TXT).
2. **Step 1: Detect whether the uploaded file is a legal document or not.**
   - If not legal ‚Üí show message: ‚ÄúThis does not appear to be a legal document. Please upload a valid rental agreement, contract, or terms of service.‚Äù
   - If legal ‚Üí proceed to analysis.
3. Extract text and clauses.
4. Summarize each clause in plain English.
5. Classify clauses (Termination, Liability, Privacy, Fees, etc.).
6. Highlight **risk levels** (Low / Medium / High) with justifications.
7. Provide a Q&A chatbot for user questions about the document.
8. Export annotated summary or annotated PDF.
9. Show disclaimer: ‚ÄúThis is not legal advice. Consult a lawyer for binding advice.‚Äù

# TECH STACK
- **Frontend**: React + Tailwind CSS (clean, responsive UI).
- **Backend**: Node.js (Express.js) REST API.
- **Database**: Firestore (NoSQL) for user metadata, sessions, and clause history.
- **File Storage**: Google Cloud Storage for uploaded documents.
- **AI Services**:
  - Google Document AI ‚Üí OCR + structured text extraction.
  - Google Vertex AI Generative Model (Gemini) ‚Üí summaries, rewrites, Q&A.
  - Vertex Matching Engine or vector DB ‚Üí RAG for grounding chatbot answers.
  - **Document Classifier**: Vertex AI model to classify text as [Legal / Not Legal] before analysis.

# FUNCTIONAL REQUIREMENTS
## Frontend
- Homepage with project intro + CTA (‚ÄúUpload Document‚Äù).
- Upload form (drag & drop + file select).
- Display results in this order:
  1. **Step 1:** Show ‚ÄúLegal document check‚Äù result (Legal ‚úÖ or Not Legal ‚ùå).
  2. If Legal ‚Üí show:
     - Overall summary (3‚Äì5 bullet points).
     - Clause-by-clause expandable cards:
       - Original text
       - Plain-English rewrite
       - Risk flag with reason
       - Suggested safer clause (if risky).
     - Chatbot UI pane for user queries.
     - Export button ‚Üí download annotated summary/PDF.
- If Not Legal ‚Üí stop pipeline and display helpful message.

## Backend
- Authentication (Firebase Auth optional).
- API Endpoints:
  - `/upload` ‚Üí upload doc to Cloud Storage + trigger Document AI parsing.
  - `/classify` ‚Üí check if the doc is legal (Legal / Not Legal).
  - `/process` ‚Üí if Legal ‚Üí summarize, classify clauses, assign risk.
  - `/chat` ‚Üí chat endpoint using RAG (doc chunks + Gemini).
  - `/export` ‚Üí return annotated summary/PDF.
- Business logic:
  - Store extracted text + clause metadata in Firestore.
  - Link file metadata to user session.
  - Delete documents on request for privacy.

# SECURITY
- All uploads encrypted in transit (HTTPS) + at rest (Cloud KMS).
- Provide "Delete Document" button for user.
- Do not log sensitive data.
- Store only minimal metadata (doc name, size, processing status).
- Show privacy disclaimer.

# OUTPUT FORMAT
Generate the **complete source code** in a structured format:
1. **Frontend (React + Tailwind)**:
   - Components: `UploadForm.jsx`, `SummaryCard.jsx`, `ClauseCard.jsx`, `Chatbot.jsx`, `ExportButton.jsx`, `LegalCheckCard.jsx`
   - Pages: `HomePage.jsx`, `UploadPage.jsx`, `ResultsPage.jsx`
   - Routing: React Router
2. **Backend (Node.js + Express)**:
   - `server.js` main entry
   - Routes: `/upload`, `/classify`, `/process`, `/chat`, `/export`
   - Middleware: file upload (Multer), auth check, error handling
   - Google Cloud SDK integration (Document AI, Vertex AI, Storage, Firestore)
   - Classifier logic ‚Üí if Not Legal, stop pipeline
3. **Database schema (Firestore)**:
   - `users/{userId}`
   - `documents/{docId}`
      - metadata
      - extracted_text
      - legal_check: true/false
      - clauses: [{id, type, summary, risk_level, original}]
4. **Storage**:
   - Google Cloud Storage bucket: `legal-doc-uploads`
5. **Configuration**:
   - `.env` with API keys, Firestore config, Vertex AI keys
6. **Run instructions**:
   - `cd frontend && npm install && npm start`
   - `cd backend && npm install && npm run dev`

# ADDITIONAL REQUIREMENTS
- Code must include inline comments for clarity.
- Provide error handling (e.g., if Document AI fails).
- Provide confidence scores in output.
- Ensure chatbot always cites clause numbers as sources.
- Ensure project runs locally with minimal setup.

Deliver a **working full-stack MVP** of LexiExplain that can be deployed on Google Cloud Run (backend) + Firebase Hosting (frontend).


‚úÖ Now the pipeline is:
Upload ‚Üí Legal/Not Legal check ‚Üí If Legal ‚Üí Full analysis ‚Üí Summary/Chat/Export ‚Üí If Not Legal ‚Üí Stop + message.

Do you also want me to add a rule that if the system is unsure (low confidence) about the "legal check," it should ask the user for confirmation before proceeding?

You said:
database and the backend all must link to the supabase 
ChatGPT said:

Perfect üëå You want the database + backend to use Supabase (instead of Firestore/Google DBs). That makes sense, because Supabase gives you Postgres + Auth + Storage + Realtime in one platform ‚Äî great for hackathons.

I‚Äôll rewrite the full-stack prompt so that:

Supabase handles database, authentication, and storage.

Backend uses Node.js + Express, but connects to Supabase (via REST or Supabase client SDK).

Frontend (React + Tailwind) talks to backend APIs.

AI pipeline still runs on Google Cloud (Document AI + Vertex AI for summarization, Q&A).

üöÄ Full-Stack Prompt with Supabase Backend + Database
You are an expert full-stack developer. Build a complete working full-stack website called **LexiExplain**, an AI-powered legal document simplifier.

# PROBLEM CONTEXT
Legal documents (rental agreements, loan contracts, terms of service) are full of jargon and hidden clauses. Users often cannot understand them, leading to financial or legal risks. Lawyers are expensive, so people need a secure, affordable AI-powered first tool to simplify documents and highlight risks.

# OBJECTIVE
Develop a secure full-stack web app that allows users to:
1. Upload legal documents (PDF, DOCX, TXT).
2. Step 1: Detect if the file is a legal document or not.  
   - If **Not Legal** ‚Üí show message: ‚ÄúThis does not appear to be a legal document.‚Äù Stop processing.  
   - If **Legal** ‚Üí continue analysis.
3. Extract text and clauses.
4. Summarize each clause in plain English.
5. Classify clauses (Termination, Liability, Privacy, Fees, etc.).
6. Highlight **risk levels** (Low / Medium / High) with reasons.
7. Provide a Q&A chatbot for document queries.
8. Export annotated summary or PDF.
9. Show disclaimer: ‚ÄúThis is not legal advice. Consult a lawyer for binding advice.‚Äù

# TECH STACK
- **Frontend**: React + Tailwind CSS  
- **Backend**: Node.js (Express.js) REST API  
- **Database & Auth**: Supabase (Postgres + Auth)  
- **File Storage**: Supabase Storage (for uploaded documents)  
- **AI Services**:  
  - Google Document AI ‚Üí OCR + text extraction  
  - Google Vertex AI (Gemini) ‚Üí summaries, plain-English rewrites, Q&A  
  - Supabase + embeddings table for RAG (clause retrieval)

# FUNCTIONAL REQUIREMENTS
## Frontend
- Homepage ‚Üí intro + ‚ÄúUpload Document‚Äù CTA  
- Upload page ‚Üí file drag/drop  
- Results page ‚Üí show:  
  - **Step 1:** Legal/Not Legal check result  
  - If Legal ‚Üí display:  
    - Overall summary  
    - Clause-by-clause expandable cards:  
      - Original text  
      - Plain-English rewrite  
      - Risk flag + justification  
      - Suggested safer alternative (if risky)  
    - Q&A chatbot  
    - Export summary/PDF  
- If Not Legal ‚Üí stop and show message  

## Backend
- Routes:  
  - `/upload` ‚Üí upload to Supabase Storage  
  - `/classify` ‚Üí check legal vs non-legal (using Vertex AI classifier)  
  - `/process` ‚Üí extract with Document AI, summarize/classify clauses with Gemini  
  - `/chat` ‚Üí RAG chatbot (clauses in Supabase embeddings table + Gemini)  
  - `/export` ‚Üí return annotated PDF/summary  
- Supabase integration:  
  - Use Supabase client to store:  
    - User metadata  
    - Documents metadata (`documents` table)  
    - Clause analysis results (`clauses` table)  
    - Embeddings for Q&A (`embeddings` table)  
- Auth: Supabase Auth (email/password or magic link)  

## Supabase Schema (Postgres)
- **users**  
  - id (uuid)  
  - email  
  - created_at  

- **documents**  
  - id (uuid)  
  - user_id (fk ‚Üí users.id)  
  - filename  
  - storage_path  
  - is_legal (boolean)  
  - uploaded_at  

- **clauses**  
  - id (uuid)  
  - document_id (fk ‚Üí documents.id)  
  - clause_text  
  - summary  
  - clause_type  
  - risk_level  
  - safer_alternative  

- **embeddings**  
  - id (uuid)  
  - clause_id (fk ‚Üí clauses.id)  
  - vector (vector type)  

## Security
- User can delete their document + metadata anytime.  
- Supabase RLS (Row Level Security) ‚Üí only owner can access their docs.  
- Backend sanitizes input and validates file type.  
- All Supabase + AI keys stored in `.env`.  

# OUTPUT FORMAT
Generate full source code:  

1. **Frontend (React + Tailwind)**  
   - Components: `UploadForm.jsx`, `LegalCheckCard.jsx`, `SummaryCard.jsx`, `ClauseCard.jsx`, `Chatbot.jsx`, `ExportButton.jsx`  
   - Pages: `HomePage.jsx`, `UploadPage.jsx`, `ResultsPage.jsx`  
   - React Router setup  
   - Supabase client for auth (login/signup UI)  

2. **Backend (Node.js + Express)**  
   - `server.js` entry  
   - Routes: `/upload`, `/classify`, `/process`, `/chat`, `/export`  
   - Middleware: file upload, Supabase client, error handling  
   - Logic:  
     - Upload file ‚Üí Supabase Storage  
     - Insert metadata ‚Üí Supabase DB  
     - Classify document ‚Üí Legal/Not Legal  
     - If Legal ‚Üí run Document AI + Gemini to process clauses  
     - Store results in Supabase tables  
     - Embed clauses into `embeddings` for Q&A  

3. **Supabase Config**  
   - `supabaseClient.js` with URL + API Key from `.env`  
   - RLS enabled  
   - SQL migration for schema  

4. **Instructions to Run**  
   - `cd frontend && npm install && npm start`  
   - `cd backend && npm install && npm run dev`  
   - Setup Supabase project, copy `.env` with URL + anon key + service key  
   - Deploy backend to Google Cloud Run (optional)  
   - Deploy frontend to Vercel/Netlify (or Supabase Hosting)  

# ADDITIONAL REQUIREMENTS
- Code must have inline comments.  
- Backend should return confidence scores.  
- Chatbot must cite clause numbers.  
- Must run locally with minimal setup.  

Deliver a **working full-stack MVP** of **LexiExplain** with Supabase as the backend + database + st